<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
  <TITLE>Epimetheus</TITLE>

  <META http-equiv=content-type content="text/html; charset=ISO-8859-1">

  <META name="author" content="Roger Lawrence">
</HEAD>
  <BODY>

<BLOCKQUOTE>
  <TABLE cellpadding=2 cellspacing=2 border=2 width="50%">
    <TBODY>
      <TR>
        <TD valign=top>
        <BLOCKQUOTE>
          <BLOCKQUOTE>
            <BLOCKQUOTE>
              <BLOCKQUOTE>
                <H1>Epimetheus</H1>
              </BLOCKQUOTE>
            </BLOCKQUOTE>
          </BLOCKQUOTE>
        </BLOCKQUOTE>
                               <BR>
                               </TD>
                               <TD valign=top>

        <BLOCKQUOTE>

          <BLOCKQUOTE>

            <H4>Not what you were looking for?</H4>
                                      </BLOCKQUOTE>
   try&nbsp;<A href="http://www.solarviews.com/eng/epimethe.htm">http://www.solarviews.com/eng/epimethe.htm</A><BR>
          <BR>
or&nbsp;<A href="http://www.theoi.com/Ouranos/Epimetheos.html">http://www.theoi.com/Ouranos/Epimetheos.html</A><BR>
                                    </BLOCKQUOTE>
                                    <BR>
                                    </TD>
                                  </TR>

    </TBODY>
  </TABLE>
 <BR>
  <BR>
Epimetheus is an implementation of the current ECMAScript 4.0 proposal in
 C++. &nbsp;It is located in the Mozilla source tree at mozilla/js2. To build,
 first see the <A href="http://www.mozilla.org/cvs.html">CVS page</A> for
details on logging in via CVS, and then:<BR>
  <B><BR>
  cvs co mozilla/js2</B><BR>
  <BR>
 will pull the complete source tree. In the js2 directory, you'll find a
README file that contains details on building. Currently there are Windows
(MSVC) and Linux build targets. The build target is a console shell executable
that supports loading .js files as well as interactive execution.<BR>
   <BR>
   Epimetheus implements most of the language as described in the current
specification.  In addition, a variety of features from the proposal have
been added as well as sufficient to enable some ECMAScript3  functionality.
For example, the ECMA3 libraries (Date, Math etc) are implemented,  but not
necessarily conforming exactly to ECMA3 prototype semantics.<BR>

  <H5>Command line options:<BR>
   </H5>

  <TABLE cellpadding=2 cellspacing=2 border=0 width="100%">
   <TBODY>
     <TR>
       <TD valign=top>-x<BR>
       </TD>
       <TD valign=top>instruction trace (see 'trace' function below)<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>-t<BR>
       </TD>
       <TD valign=top>parse tree printout (see 'trees' function below)<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>-f &lt;filename&gt;<BR>
       </TD>
       <TD valign=top>load and execute a .js file. Multiple -f options
 can be specified, the shell quits after loading the last one<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>-i<BR>
       </TD>
       <TD valign=top>enter interactive mode (used after  a -f option)<BR>
       </TD>
     </TR>

    </TBODY>
  </TABLE>

  <H5>Shell functions:</H5>

  <TABLE cellpadding=2 cellspacing=2 border=0 width="100%">
   <TBODY>
     <TR>
       <TD valign=top>dump(&lt;arg&gt;)<BR>
       </TD>
       <TD valign=top>prints a diagnostic inspection of the argument (currently
only implemented for bytecode functions, classes and prototype instances)<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>load(&lt;string&gt;)<BR>
       </TD>
       <TD valign=top>loads and executes the .js file specified  by the
string argument.<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>print(&lt;arg&gt;, ..)<BR>
       </TD>
       <TD valign=top>prints the 'toString' value of each argument<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>trees()<BR>
       </TD>
       <TD valign=top>toggles the state of the flag that controls printing
of parse trees<BR>
       </TD>
     </TR>
     <TR>
       <TD valign=top>trace()<BR>
       </TD>
       <TD valign=top>toggles the state of the flag that controls instruction
tracing.<BR>
       </TD>
     </TR>

    </TBODY>
  </TABLE>
 <BR>

  <H4>What's missing:</H4>
  There are holes in the specification - the implementation will track these
 as they get addressed. Notably; constructor semantics, method invocation.<BR>
  Type optimization - currently only supports converting member access by
name  to direct slot access, much more is possible.<BR>
   The GC - it's very much a junior woodchuck level design, at best it proves
 survival under memory pertubation.<BR>
   ECMA3 semantics &amp; SpiderMonkey compatibility - very much not in place.<BR>
  Runtime model - needs to be further weaned from semantics based model,
and  performance<BR>

  <H4><BR>
  </H4>

  <H4>Example:</H4>
  D:\ns_trunk\mozilla\js2\src\winbuild\Epimetheus\Debug&gt;<B>epimetheus</B><BR>
  Welcome to Epimetheus.<BR>
  ep&gt; <B>namespace ns1</B><BR>
  ep&gt; <B>namespace ns2</B><BR>
  ep&gt; <B>class A { ns1 var x; ns2 var x; function f() { return ns1::x;
} }</B><BR>
  ep&gt; <B>class B extends A { override function f() { return ns2::x; }
}</B><BR>
  ep&gt; <B>b = new B()</B><BR>
  object<BR>
  ep&gt; <B>b.ns1::x = 1</B><BR>
  1<BR>
  ep&gt; <B>b.ns2::x = 2</B><BR>
  2<BR>
  ep&gt; <B>b.f()</B><BR>
  2<BR>
  ep&gt;<BR>
  <BR>

  <H4>Internals:</H4>
  (under construction)<BR>
  <BR>
  Parser (ad hoc, recursive descent) produces trees; see classes StmtNode
&amp; ExprNode in parser.h<BR>
  <BR>
  Semantics engine (JS2Metadata) consumes trees in two passes, modeled on
design in ECMA document (Validate &amp; Evaluate).<BR>
  &nbsp;&nbsp;&nbsp; Validate pass; begins building symbol tables, gathers
 type information, does attribute evaluation.<BR>
  &nbsp;&nbsp;&nbsp; Evaluate pass; generates bytecode into bytecodeContainer
 module.<BR>
  &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (either pass might invoke the interpreter
 for evaluation of attributes &amp; other compile-time constants).<BR>
  BytecodeContainer; 1 per function (or script block). Maintains gc-accessible
 lists of multinames, string etc.<BR>
  <BR>
  Interpreter (JS2Engine)<BR>
  Stack based bytecode, very SpiderMonkey like. JS Invocations don't use
C-stack<BR>
  Tagged values (like SpiderMonkey but using 4 bits because of long etc -
would like to consider separate type stack)<BR>
  Try/Catch mechanism - separate stack of handlers. Will re-throw across
invocations.<BR>
  Runtime model is a work in progress - currently the object layout owes
too  much to the semantic description from the proposal.<BR>
  <BR>
  GC<BR>
  Simple mark-and-sweep-to-free-list implementation. Requires cooperation
from each runtime-stage data structure to recursively mark contained objects.<BR>
  <BR>
  ECMA3 library support (js2array.cpp, js2date.cpp, js2math.cpp, js2number.cpp,
 js2regexp.cpp, js2string.cpp)<BR>
  Implementation per ECMA3 spec. but against new runtime model.<BR>
  X.prototype properties implemented as instance methods (except Math properties
 which were more comfortable as static members)<BR>
  <BR>
  Known issues:<BR>
 <BR>
 Object layout, property map<BR>
 Strings, StringAtoms etc. Not consistently handled/gc'd.<BR>
 Long/ULong arithmetic - doesn't catch overflow etc.<BR>
 <BR>
 <BR>

  <H4><BR>
  </H4>
  <BR>
   </BLOCKQUOTE>
</BODY>
</HTML>
