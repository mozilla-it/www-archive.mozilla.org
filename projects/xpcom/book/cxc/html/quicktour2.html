<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<meta name="GENERATOR" content="Quadralay WebWorks Publisher Professional Edition 6.0.5">
<meta name="TEMPLATEBASE" content="Portable HTML Professional Edition">
<meta name="LASTUPDATED" content="07/02/03 09:55:39">
<title>CHAPTER 1 What Is XPCOM?</title>
</head>

<body link="#3366CC" vlink="#9999CC" text="#000000" alink="#0000CC" bgcolor="#FFFFFF">

<table width="331" border="0" align="right" cellpadding="0" cellspacing="0">
  <tr>
    <td><a href="newbookTOC.html"><img src="images/navtoc.gif" width="84" height="23"
    border="0" alt="TOC"> </a></td>
    <td><a href="preface.html"><img src="images/navprev.gif" width="81" height="23"
    border="0" alt="PREV"> </a></td>
    <td><a href="using_components.html"><img src="images/navnext.gif" width="81" height="23"
    border="0" alt="NEXT"> </a></td>
    <td><a href="newbookIX.html"><img src="images/navidx.gif" width="85" height="23"
    border="0" alt="INDEX"> </a></td>
  </tr>
</table>

<p><img src="images/xpcom.gif"></p>
<hr align="left">

<blockquote>
<h1>
  <a name="1003424"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">CHAPTER 1	 What Is XPCOM?</font>
</h1><hr>


<p>
  <a name="998204"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">This is a book about XPCOM. The book is written in the form of a tutorial about creating XPCOM components, but it covers all major aspects, concepts, and terminology of the XPCOM component model along the way. </font>
</p>


<p>
  <a name="998205"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">This chapter starts with a quick tour of XPCOM-an introduction to the basic concepts and technologies in XPCOM and  component development. The brief sections in this chapter introduce the concepts at a very high-level, so that we can discuss and use them with more familiarity in the tutorial itself, which describes the creation of a Mozilla component called <font  face="Verdana, Arial, Helvetica, sans-serif"><b>WebLock</b></font>. </font>
</p>

<ul>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998208"> </a><a href="quicktour2.html#998244">"The XPCOM Solution"</a> </font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998212"> </a><a href="quicktour2.html#1003987">"Components"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998216"> </a><a href="quicktour2.html#1003494">"Interfaces"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998220"> </a><a href="quicktour2.html#1003569">"Factories"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998225"> </a><a href="quicktour2.html#1003594">"XPCOM Services"</a></font>
</ul>

<h2>
  <a name="998244"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">The XPCOM Solution</font>
</h2>


<p>
  <a name="998245"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The Cross Platform Component Object Module (XPCOM) is a framework which allows developers to break up monolitic software projects into smaller modularized pieces. These pieces, known as <font  face="Verdana, Arial, Helvetica, sans-serif"><i>components</i></font>, are then assembled back together at runtime. </font>
</p>


<p>
  <a name="1004104"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The goal of XPCOM is to allow different pieces of software to be developed and built independently of one another. In order to allow interoperability between components within an application, XPCOM separates the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>implementation</i></font> of a component from the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>interface</i></font>, which we discuss in the <a href="quicktour2.html#1003494">"Interfaces"</a> section. But XPCOM also provides several tools and libraries that enable the loading and manipulation of these components, services that help the developer write modular cross-platform code, and versioning support, so that components can be replaced or upgraded without breaking or having to recreate the application. Using XPCOM, developers create components that can be reused in different applications or that can be replaced to change the functionality of existing applications. </font>
</p>


<p>
  <a name="1004180"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">XPCOM not only supports component software development, it also provides much of the functionality that a development platform  provides, such as:</font>
</p>

<ul>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998248"> </a>component management</font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998249"> </a>file abstraction</font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998250"> </a>object message passing</font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="998251"> </a>memory management</font>
</ul>

<p>
  <a name="998253"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">We will discuss the above items in detail in the coming chapters, but for now, it can be useful to think of XPCOM as a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>platform for component development</i></font>, in which features such as those listed above are provided.</font>
</p>


<h2>
  <a name="1001898"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Gecko</font>
</h2>


<p>
  <a name="1001904"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Although it is in some ways structurally similar to Microsoft COM, XPCOM is designed to be used principally at the application level. The most important use of XPCOM is within <font  face="Verdana, Arial, Helvetica, sans-serif"><i>Gecko</i></font>, an open source, standards compliant, embeddable web browser and toolkit for creating web browsers and other applications.</font>
</p>


<p>
  <a name="1001917"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">XPCOM is the means of accessing Gecko library functionality and embedding or extending Gecko. This book focuses on the latter-extending Gecko-but the fundamental ideas in the book will be important to developers embedding Gecko as well.</font>
</p>


<p>
  <a name="1001905"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Gecko is used in many internet applications, mostly browsers. The list includes devices such as the Gateway/AOL Instant AOL device and the Nokia Media Terminal. Gecko is also used in the latest Compuserve client, AOL for Mac OS X, Netscape 7, and of course the Mozilla client. At this time, Gecko is the predominant open source web browser.</font>
</p>


<h2>
  <a name="1003987"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Components</font>
</h2>


<p>
  <a name="1003463"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">XPCOM allows you to build a system in which large software projects can be broken up into smaller pieces. These pieces, known as components, are usually delivered in small, reusable binary libraries (a DLL on Windows, for example, or a DSO on Unix), which can include one or more components. When there are two or more related components together in a binary library, the library is referred to as a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>module</i></font>.</font>
</p>


<p>
  <a name="1003464"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Breaking software into different components can help make it less difficult to develop and maintain. Beyond this, modular, component-based programming has some well-known advantages, as Table 1 describes:<font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003467"> </a><font face="Times New Roman">TABLE 1.  Benefits from Modular Code</font></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003471"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Benefit</font></font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003473"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Description</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003475"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Reuse</font></font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003477"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Modular code can be reused in other applications and other contexts</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003479"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Updates</font></font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003481"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">You can update components without having to recompile the whole application</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003483"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Performance</font></font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003485"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When code is modularized, modules that are not necessary right away can be "lazy loaded", or not loaded at all, which can improve the performance of your application.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003487"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Maintenance</font></font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1003489"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Even when you are not updating a component, designing your appication in a modular way can make it easier for you to find and maintain the parts of the application that you are interested in.</font></font></td>
  </tr>
</table>



</font></font>
</p>


<p>
  <a name="1003490"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Mozilla has over four million lines of code, and no single individual understands the entire codebase. The best way to tackle a project of this size is to divide it into smaller, more managable pieces, use a component programming model, and to organize related sets of components into modules. The network library, for example, consists of components for each of the protocols, HTTP, FTP, and others, which are bundled together and linked into a single library. This library is the networking module, also known as "necko."</font>
</p>


<p>
  <a name="1003491"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">But it's not always a good idea to divide things up. There are some things in the world that just go together, and others that shouldn't be apart. For example, one author's son will not eat a peanutbutter sandwich if there isn't jam on it, because in his world, peanut butter and jam form an indelible union. Some software is the same. In areas of code that are tightly-coupled-in classes that are only used internally, for example-the expensive work to divide things may not be worth the effort.</font>
</p>


<p>
  <a name="1003492"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The HTTP component in Gecko doesn't expose private classes it uses as separate components. The "stuff" that's internal to the component stays internal, and isn't exposed to XPCOM. In the haste of early Mozilla development, components were created where they were inappropriate, but there's been an ongoing effort to remove XPCOM from places like this.</font>
</p>


<h2>
  <a name="1003494"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Interfaces</font>
</h2>


<p>
  <a name="1003495"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">It's generally a good idea to break software into components, but how exactly do you do this? The basic idea is to identify the pieces of functionality that are related and understand how they communicate with each other. The communication channels between different component form boundaries between those components, and when those boundaries are formalized they are known as <font  face="Verdana, Arial, Helvetica, sans-serif"><i>interfaces</i></font>.</font>
</p>


<p>
  <a name="1003496"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Interfaces aren't a new idea in programming. We've all used interfaces since our first "HelloWorld" program, where the interface was between the code we actually wrote-the application code-and the printing code. The application code used an interface from a library, <font  face="Verdana, Arial, Helvetica, sans-serif">stdio</font>, to print the "hello world" string out to the screen. The difference here is that a "HelloWorld" application in XPCOM finds this screen-printing functionality at runtime and never has to know about <font  face="Verdana, Arial, Helvetica, sans-serif">stdio</font> when it's compiled.</font>
</p>


<p>
  <a name="1003497"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Interfaces allow developers to <font  face="Verdana, Arial, Helvetica, sans-serif"><i>encapsulate </i></font>the implementation and inner workings of their software, and allow clients to ignore how things are made and just use that software. </font>
</p>


<a name="1003498"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif">
<h4>
  <a name="1004132"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Interfaces and Programming by Contract</font>
</h4>


<p>
  <a name="1004143"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">An interface forms a contractual agreement between components and clients. There is no code that enforces these agreements, but ignoring them can be fatal. In component-based programming, a component guarantees that the interfaces it provides will be <font  face="Verdana, Arial, Helvetica, sans-serif"><i>immutable-</i></font>that they will provide the same access to the same methods across different versions of the component-establishing a contract with the software clients that use it. In this respect, interface-based programming is often referred to as <font  face="Verdana, Arial, Helvetica, sans-serif"><i>programming by contract</i></font>.</font>
</p>

</font></td>
  </tr>
</table>



<br></font>


<h3>
  <a name="1003499"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Interfaces and Encapsulation</font>
</h3>


<p>
  <a name="1003500"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Between component boundaries, abstraction is crucial for software maintainability and reusability. Consider, for example, a class that <font  face="Verdana, Arial, Helvetica, sans-serif"><i>isn't</i></font> well encapsulated. Using a freely available public initialization method, as the example below suggests, can cause problems.</font>
</p>


<a name="998313"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">class SomeClass </font><a name="1001793"> </a>
<font face="Courier New">{</font><a name="1001794"> </a>
<font face="Courier New">  public:</font><a name="1001795"> </a>
<font face="Courier New">    // Constructor</font><a name="1001796"> </a>
<font face="Courier New">    SomeClass();</font><a name="1001797"> </a>
<font face="Courier New"></font><a name="1001798"> </a>
<font face="Courier New">    // Virtual Destructor</font><a name="1001799"> </a>
<font face="Courier New">    virtual ~SomeClass();</font><a name="1001800"> </a>
<font face="Courier New"></font><a name="1001801"> </a>
<font face="Courier New">    // init method</font><a name="1001802"> </a>
<font face="Courier New">    void Init();</font><a name="1001803"> </a>
<font face="Courier New"></font><a name="1001804"> </a>
<font face="Courier New">    void DoSomethingUseful();</font><a name="1001805"> </a>
<font face="Courier New">};</font><a name="1001806"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="998315"> </a><font face="Times New Roman">Figure 1.  SomeClass Class Initialization</font>
<p>
  <a name="1003507"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">For this system to work properly, the client programmer must pay close attention to whatever rules the component programmer has established. This is the contractual agreement of this unencapsulated class: a set of rules that define when each method can be called and what it is expected to do. One rule might specify that <font  face="Verdana, Arial, Helvetica, sans-serif">DoSomethingUseful</font> may only be called after a call to <font  face="Verdana, Arial, Helvetica, sans-serif">Init()</font>. The <font  face="Verdana, Arial, Helvetica, sans-serif">DoSomethingUseful</font> method may do some kind of checking to ensure that the condition-that <font  face="Verdana, Arial, Helvetica, sans-serif">Init</font> has been called-has been satisfied.</font>
</p>


<p>
  <a name="1000167"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In addition to writing well-commented code that tells the client developer the rules about <font  face="Verdana, Arial, Helvetica, sans-serif">Init()</font>, the developer can take a couple steps to make this contract even clearer. First, the construction of an object can be encapsulated, and a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>virtual class</i></font> provided that defines the <font  face="Verdana, Arial, Helvetica, sans-serif">DoSomethingUseful</font> method. In this way, construction and initialization can be completely hidden from clients of the class. In this "semi-encapsulated" situation, the only part of the class that is exposed is a well-defined list of callable methods (i.e., the interface). Once the class is encapsulated, the only interface the client will see is this:</font>
</p>


<a name="998328"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">class SomeInterface</font><a name="1001775"> </a>
<font face="Courier New">{</font><a name="1001776"> </a>
<font face="Courier New">public:</font><a name="1001777"> </a>
<font face="Courier New">  virtual void DoSomethingUseful() = 0;</font><a name="1001778"> </a>
<font face="Courier New">};</font><a name="1001779"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="998330"> </a><font face="Times New Roman">Figure 2.  Encapsulation of SomeInterface</font>
<p>
  <a name="1003513"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The implementation can then derive from this class and implement the virtual method. Clients of this code can then use a factory design pattern to create the object (see <a href="quicktour2.html#1003569">"Factories" on page 20</a>) and further encapsulate the implementation. In XPCOM, clients are shielded from the inner workings of components in this way and rely on the interface to provide access to the needed functionality.</font>
</p>


<h3>
  <a name="1003519"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">The nsISupports Base Interface</font>
</h3>


<p>
  <a name="1003520"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Two fundamental issues in component and interface-based programming are <font  face="Verdana, Arial, Helvetica, sans-serif"><i>component lifetime</i></font>, also called <font  face="Verdana, Arial, Helvetica, sans-serif"><i>object ownership</i></font>, and <font  face="Verdana, Arial, Helvetica, sans-serif"><i>interface querying</i></font>, or being able to identify which interfaces a component supports at run-time. This section introduces the base interface-the mother of all interfaces in XPCOM-<font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font>, which provides solutions to both of these issues for XPCOM developers.</font>
</p>


<h5>
  <a name="1003521"> </a><i><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Object Ownership</font></i>
</h5>


<p>
  <a name="1003522"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In XPCOM, since components may implement any number of different interfaces, interfaces must be <font  face="Verdana, Arial, Helvetica, sans-serif"><i>reference counted</i></font>. Components must keep track of how many references to it clients are maintaining and delete themselves when that number reaches zero. </font>
</p>


<p>
  <a name="1003523"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When a component gets created, an integer inside the component tracks this reference count. The reference count is incremented automatically when the client  instantiates the component; over the course of the component's life, the reference count goes up and down, always staying above zero. At some point, all clients lose interest in the component, the reference count hits zero, and the component deletes itself.</font>
</p>


<p>
  <a name="1003524"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When clients use interfaces responsibly, this can be a very straightforward process. XPCOM has tools to make it even easier, as we describe later. It can raise some real housekeeping problems when, for example, a client uses an interface and forgets to decrement the reference count. When this happens, interfaces may never be released and will leak memory. The system of reference counting is, like many things in XPCOM, a contract between clients and implementations. It works when people agree to it, but when they don't, things can go wrong. It is the responsibility of the function that creates the interface pointer to add the initial reference, or <font  face="Verdana, Arial, Helvetica, sans-serif"><i>owning reference</i></font>, to the count.</font>
</p>


<a name="1004280"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif">
<h4>
  <a name="1004286"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Pointers in XPCOM</font>
</h4>

<a name="1004287"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In XPCOM, <font  face="Verdana, Arial, Helvetica, sans-serif"><i>pointers</i></font> refer to interface pointers. The difference is a subtle one, since interface pointers and regular pointers are both just address in memory. But an interface pointer is known to implement the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> base interface, and so can be used to call methods such as <font  face="Verdana, Arial, Helvetica, sans-serif">AddRef</font>, <font  face="Verdana, Arial, Helvetica, sans-serif">Release</font>, or <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font>.</font></font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="998356"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"><font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font>, shown below, supplies the basic functionality for dealing with interface discovery and reference counting. The members of this interface, <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font>, <font  face="Verdana, Arial, Helvetica, sans-serif">AddRef</font>, and <font  face="Verdana, Arial, Helvetica, sans-serif">Release</font>, provide the basic means for getting the right interface from an object, incrementing the reference count, and releasing objects once they are not being used, respectively. <a href="quicktour2.html#998377"><font  face="Verdana, Arial, Helvetica, sans-serif"><i>Figure 3</i></font></a> shows the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface. </font>
</p>


<a name="998375"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">class Sample: public nsISupports {  </font><a name="1001746"> </a>
<font face="Courier New">private:  </font><a name="1001747"> </a>
<font face="Courier New">  nsrefcnt mRefCnt;  </font><a name="1001748"> </a>
<font face="Courier New">public:  </font><a name="1001749"> </a>
<font face="Courier New">  Sample();  </font><a name="1001750"> </a>
<font face="Courier New">  virtual ~Sample();  </font><a name="1001751"> </a>
<font face="Courier New"></font><a name="1001752"> </a>
<font face="Courier New">  NS_IMETHOD QueryInterface(const nsIID &amp;aIID, void **aResult);  </font><a name="1001753"> </a>
<font face="Courier New">  NS_IMETHOD_(nsrefcnt) AddRef(void);  </font><a name="1001754"> </a>
<font face="Courier New">  NS_IMETHOD_(nsrefcnt) Release(void);  </font><a name="1001755"> </a>
<font face="Courier New"></font><a name="1001756"> </a>
<font face="Courier New">};</font><a name="1001757"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="998377"> </a><font face="Times New Roman">Figure 3.  The nsISupports Interface</font>
<p>
  <a name="998378"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The various types used in this figure are described in the <a href="quicktour2.html#1004604">"XPCOM Types"</a> section below. <a href="quicktour2.html#998425"><font  face="Verdana, Arial, Helvetica, sans-serif"><i>Figure 4</i></font></a> shows a complete (if spare) implementation of the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface.</font>
</p>


<a name="998423"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">Sample::Sample()  </font><a name="1001694"> </a>
<font face="Courier New">{  </font><a name="1001695"> </a>
<font face="Courier New">  // initialize the reference count to 0</font><a name="1004326"> </a>
<font face="Courier New">  mRefCnt = 0;  </font><a name="1001696"> </a>
<font face="Courier New">}  </font><a name="1001697"> </a>
<font face="Courier New">Sample::~Sample()  </font><a name="1001698"> </a>
<font face="Courier New">{  </font><a name="1001699"> </a>
<font face="Courier New">}  </font><a name="1001700"> </a>
<font face="Courier New"></font><a name="1001701"> </a>
<font face="Courier New">// typical, generic implementation of QI</font><a name="1001702"> </a>
<font face="Courier New">NS_IMETHODIMP Sample::QueryInterface(const nsIID &amp;aIID,  </font><a name="1001703"> </a>
<font face="Courier New">                                  void **aResult)  </font><a name="1001704"> </a>
<font face="Courier New">{  </font><a name="1001705"> </a>
<font face="Courier New">  if (aResult == NULL) {  </font><a name="1001706"> </a>
<font face="Courier New">    return NS_ERROR_NULL_POINTER;  </font><a name="1001707"> </a>
<font face="Courier New">  } </font><a name="1001708"> </a>
<font face="Courier New">  *aResult = NULL;  </font><a name="1001709"> </a>
<font face="Courier New">  if (aIID.Equals(kISupportsIID)) {  </font><a name="1001710"> </a>
<font face="Courier New">    *aResult = (void *) this;  </font><a name="1001711"> </a>
<font face="Courier New">  } </font><a name="1001712"> </a>
<font face="Courier New">  if (*aResult != NULL) {  </font><a name="1001713"> </a>
<font face="Courier New">    return NS_ERROR_NO_INTERFACE;  </font><a name="1001714"> </a>
<font face="Courier New">  }  </font><a name="1001715"> </a>
<font face="Courier New">  // add a reference</font><a name="1004327"> </a>
<font face="Courier New">  AddRef();  </font><a name="1001716"> </a>
<font face="Courier New">  return <font  face="Verdana, Arial, Helvetica, sans-serif">NS_OK</font>;  </font><a name="1001717"> </a>
<font face="Courier New">}  </font><a name="1001718"> </a>
<font face="Courier New"></font><a name="1001719"> </a>
<font face="Courier New">NS_IMETHODIMP_(nsrefcnt) Sample::AddRef()  </font><a name="1001720"> </a>
<font face="Courier New">{  </font><a name="1001721"> </a>
<font face="Courier New">  return ++mRefCnt;  </font><a name="1001722"> </a>
<font face="Courier New">}  </font><a name="1001723"> </a>
<font face="Courier New"></font><a name="1001724"> </a>
<font face="Courier New">NS_IMETHODIMP_(nsrefcnt) Sample::Release()  </font><a name="1001725"> </a>
<font face="Courier New">{  </font><a name="1001726"> </a>
<font face="Courier New">  if (--mRefCnt == 0) {  </font><a name="1001727"> </a>
<font face="Courier New">    delete this;  </font><a name="1001728"> </a>
<font face="Courier New">    return 0;  </font><a name="1001729"> </a>
<font face="Courier New">  }  </font><a name="1001730"> </a>
<font face="Courier New">  // optional: return the reference count</font><a name="1004328"> </a>
<font face="Courier New">  return mRefCnt;  </font><a name="1001731"> </a>
<font face="Courier New">}</font><a name="1001732"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="998425"> </a><font face="Times New Roman">Figure 4.  Implementation of nsISupports Interface</font>
<h5>
  <a name="1003546"> </a><i><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Object Interface Discovery</font></i>
</h5>


<p>
  <a name="1003536"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"><font  face="Verdana, Arial, Helvetica, sans-serif"><i>Inheritance</i></font> is another very important topic in object oriented programming. Inheritance is the means through which one class is derived from another. When a class inherits from another class, the inheriting class may <font  face="Verdana, Arial, Helvetica, sans-serif"><i>override</i></font> the default behaviors of the base class without having to copy all of that class's code, in effect creating a more specific class, as in the following example:</font>
</p>


<a name="1001618"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">class Shape</font></font><a name="1001628"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">{ </font></font><a name="1001629"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">private:</font></font><a name="1001630"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">  int m_x;</font></font><a name="1001631"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">  int m_y;</font></font><a name="1001632"> </a>
<font face="Courier New"></font><a name="1001633"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">public:</font></font><a name="1001634"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">  virtual void Draw() = 0;</font></font><a name="1001635"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">  Shape();</font></font><a name="1001636"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">  virtual ~Shape();</font></font><a name="1001637"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">};</font></font><a name="1001638"> </a>
<font face="Courier New"></font><a name="1001639"> </a>
<font face="Courier New"></font><a name="1001640"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">class Circle : public Shape</font></font><a name="1001641"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">{</font></font><a name="1001642"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">private:</font></font><a name="1001643"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">   int m_radius;</font></font><a name="1001644"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">public:</font></font><a name="1001645"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">   virtual Draw();</font></font><a name="1001646"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">   Circle(int x, int y, int radius);</font></font><a name="1001647"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">   virtual ~Circle();</font></font><a name="1001648"> </a>
<font face="Courier New"><font  face="Verdana, Arial, Helvetica, sans-serif">};</font></font><a name="1001649"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="1003557"> </a><font face="Times New Roman">Figure 5.  Simple Class Inheritance</font>
<p>
  <a name="1004479"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"><font  face="Verdana, Arial, Helvetica, sans-serif">Circle</font> is a derived class of <font  face="Verdana, Arial, Helvetica, sans-serif">Shape</font>. A <font  face="Verdana, Arial, Helvetica, sans-serif">Circle</font> is a <font  face="Verdana, Arial, Helvetica, sans-serif">Shape</font>, in other words, but a <font  face="Verdana, Arial, Helvetica, sans-serif">Shape</font> is not necessarily a <font  face="Verdana, Arial, Helvetica, sans-serif">Circle</font>. In this case, Shape is the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>base class</i></font> and Circle is a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>subclass</i></font> of Shape. </font>
</p>


<p>
  <a name="1004459"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In XPCOM, all classes derive from the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface, so all objects are <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> but they are also other, more specific classes, which you need to be able to find out about at runtime. In <a href="quicktour2.html#1003557"><font  face="Verdana, Arial, Helvetica, sans-serif"><i>Figure 5</i></font></a> above, for example, you'd like to be able ask the <font  face="Verdana, Arial, Helvetica, sans-serif">Shape</font> if it's a <font  face="Verdana, Arial, Helvetica, sans-serif">Circle</font> and to be able to use it like a circle if it is. In XPCOM, this is what the <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> feature of the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface is for: it allows clients to find and access different interfaces based on their needs. </font>
</p>


<p>
  <a name="1003558"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In C++, you can use a fairly advanced feature known as a <font  face="Verdana, Arial, Helvetica, sans-serif">dynamic_cast&lt;&gt;</font>, which throws an exception if the <font  face="Verdana, Arial, Helvetica, sans-serif">Shape</font> object is not able to be cast to a <font  face="Verdana, Arial, Helvetica, sans-serif">Circle</font>. But enabling exceptions and RTTI may not be an option because of performance overhead and compatibility on many platforms, so XPCOM does things differently. </font>
</p>


<a name="1004292"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif">
<h4>
  <a name="1004299"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">"Exceptions" in XPCOM</font>
</h4>

<a name="1004300"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">C++ exceptions are not supported directly by XPCOM. Instead all exceptions must be handled within a given component, before crossing interface boundaries. In XPCOM, all interface methods should return an <font  face="Verdana, Arial, Helvetica, sans-serif">nsresult</font> error value (see the XPCOM API in Appendix B for a listing of these error codes). These error code results become the "exceptions" that XPCOM handles.</font></font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="1004293"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Instead of leveraging C++ RTTI, XPCOM uses the special <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> method that casts the object to the right interface if that interface is supported. </font>
</p>


<p>
  <a name="1005428"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Every interface is assigned an identifier that gets generated from a tool commonly named "uuidgen".  This universally unique identifier (UUID) is a unique, 128 bit number. Used in the context of an interface (as opposed to a component, which is what the contract ID is for), this number is called an <font  face="Verdana, Arial, Helvetica, sans-serif"><i>IID</i></font>.</font>
</p>


<p>
  <a name="1005429"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When a client wants to discover if an object supports a given interface, the client passes the IID assigned to that interface into the <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> method of that object. If the object supports the requested interface, it adds a reference to itself and passes back a pointer to that interface. If the object does not support the interface an error is returned.</font>
</p>


<a name="1005438"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">class nsISupports {</font><a name="1005432"> </a>
<font face="Courier New"> 	public: </font><a name="1005433"> </a>
<font face="Courier New">		long QueryInterface(const nsIID &amp; uuid, 
					void **result) = 0;</font><a name="1005434"> </a>
<font face="Courier New">		long AddRef(void) = 0;</font><a name="1005435"> </a>
<font face="Courier New">		long Release(void) = 0;</font><a name="1005436"> </a>
<font face="Courier New">};</font><a name="1005437"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="1005439"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The first parameter of <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> is a reference to a class named <font  face="Verdana, Arial, Helvetica, sans-serif">nsIID</font>, which is a basic encapsulation of the IID. Of the  three methods on the <font  face="Verdana, Arial, Helvetica, sans-serif">nsIID</font> class, <font  face="Verdana, Arial, Helvetica, sans-serif">Equals</font>, <font  face="Verdana, Arial, Helvetica, sans-serif">Parse</font>, and <font  face="Verdana, Arial, Helvetica, sans-serif">ToString</font>, <font  face="Verdana, Arial, Helvetica, sans-serif">Equals</font> is by far the most important, because it is used to compare two <font  face="Verdana, Arial, Helvetica, sans-serif">nsIID</font>s in this interface querying process.</font>
</p>


<p>
  <a name="1005454"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When
you implement the <font  face="Verdana, Arial, Helvetica, sans-serif">nsIID</font>
class (and you'll see in the chapter <a href="tools.html#1007132">"Tutorial: Using
XPCOM Utilities To Make Things Easier"</a> how macros can make this process much
easier), you must make sure the class methods return a valid result when the client
calls <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> with
the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> IID. <font
face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font> should support
all interfaces that the component supports.</font>
</p>


<p>
  <a name="1005498"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In
implementations of <font  face="Verdana, Arial, Helvetica, sans-serif">QueryInterface</font>,
the IID argument is checked against the <font
face="Verdana, Arial, Helvetica, sans-serif">nsIID</font> class. If there is a match,
the object's <font  face="Verdana, Arial, Helvetica, sans-serif">this</font> pointer
is cast to <font  face="Verdana, Arial, Helvetica, sans-serif">void</font>, the
reference count is incremented, and the interface returned to the caller. If there
isn't a match, the class returns an error and sets the out value to <font
face="Verdana, Arial, Helvetica, sans-serif">null</font>. </font>
</p>


<p>
  <a name="1005499"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In the
example above, it's easy enough to use a C-style cast. But casting can become more
involved where you must first cast void then to the requested type, because you must
return the interface pointer in the vtable corresponding to the requested interface.
Casting can become a problem when there is an ambiguous inheritance hierarchy.</font>
</p>


<h2>
  <a name="1005456"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">XPCOM Identifiers</font>
</h2>


<p>
  <a name="1005463"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In addition to the IID interface identifier discussed in the previous section, XPCOM uses two other very important identifiers to distinguish classes and components.</font>
</p>

<ul>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1005460"> </a><a href="quicktour2.html#1005329">"CID"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1005397"> </a><a href="quicktour2.html#1005005">"Contract ID"</a></font>
</ul>

<h3>
  <a name="1005329"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">CID</font>
</h3>


<p>
  <a name="1004987"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">A CID is a 128 bit number that uniquely identifies a class or component in much the same way that an IID uniquely identifies an interface. The CID for <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> looks like this:</font>
</p>

<pre>
<font face="Courier New">00000000-0000-0000-c000-000000000046</font><a name="1004990"> </a>
</pre>

<p>
  <a name="1004992"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The length of a CID can make it cumbersome to deal with in the code, so very often you see #defines for CIDs and other identifiers being used, as in this example:</font>
</p>


<a name="1005275"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">#define SAMPLE_CID \</font><a name="1005286"> </a>
<font face="Courier New">{ 0x777f7150, 0x4a2b, 0x4301, \</font><a name="1005287"> </a>
<font face="Courier New">{ 0xad, 0x10, 0x5e, 0xab, 0x25, 0xb3, 0x22, 0xaa}}</font><a name="1005288"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="1004999"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">You also see <font  face="Verdana, Arial, Helvetica, sans-serif">NS_DEFINE_CID</font> used a lot. This simple macro declares a constant with the value of the CID:</font>
</p>

<pre>
<font face="Courier New">static NS_DEFINE_CID(kWebShellCID, NS_WEB_SHELL_CID);</font><a name="1005001"> </a>
</pre>

<p>
  <a name="1005003"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">A CID is sometimes also referred to as a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>class identifier</i></font>. If the class to which a CID refers implements more than one interface, that CID guarantees that the class implements that whole set of interfaces when it's published or frozen.</font>
</p>


<h3>
  <a name="1005005"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Contract ID</font>
</h3>


<p>
  <a name="1005006"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">A contract ID is a human readable string used to access a component. A CID or a contract ID may be used to get a component from the component manager. This is the contract ID for the LDAP Operation component:</font>
</p>

<pre>
<font face="Courier New">"@mozilla.org/network/ldap-operation;1"</font><a name="1005008"> </a>
</pre>

<p>
  <a name="1005010"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The format of the contract ID is the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>domain</i></font> of the component, the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>module</i></font>, the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>component name</i></font>, and the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>version number</i></font>, separated by slashes.</font>
</p>


<p>
  <a name="1005012"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Like a CID, a contract ID refers to an implementation rather than an interface, as an IID does. But a contract ID is not bound to any specific implementation, as the CID is, and is thus more general. Instead, a contract ID only specifies a given set of interfaces that it wants implemented, and any number of different CIDs may step in and fill that request. This difference between a contract ID and a CID is what makes it possible to override components.</font>
</p>


<a name="1005472"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif">
<h4>
  <a name="1005479"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">XPCOM Identifier Classes</font>
</h4>

<a name="1005480"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The <font  face="Verdana, Arial, Helvetica, sans-serif">nsIID</font> class is actually a typedef for the <font  face="Verdana, Arial, Helvetica, sans-serif">nsID</font> class. The other typedefs of <font  face="Verdana, Arial, Helvetica, sans-serif">nsID</font>, CID and IID, refer to specific implementations of a concrete class and to a specific interface, respectively.</font><a name="1005512"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The nsID class provides methods like Equals for comparing identifiers in the code. See <a href="components.html#1001190">"Identifiers in XPCOM" on page 60</a> for more discussion of the <font  face="Verdana, Arial, Helvetica, sans-serif">nsID</font> classes. </font></font></td>
  </tr>
</table>



<br></font>


<h2>
  <a name="1003569"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Factories</font>
</h2>


<p>
  <a name="1003570"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Once code is broken up into components, client code typically uses the <font  face="Verdana, Arial, Helvetica, sans-serif">new</font> constructor to instantiate objects for use: </font>
</p>

<pre>
<font face="Courier New">SomeClass* component = new SomeClass();</font><a name="1003571"> </a>
</pre>

<p>
  <a name="1003572"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">This pattern requires that the client know something about the component, however-how big it is at the very least. The <font  face="Verdana, Arial, Helvetica, sans-serif"><i>factory design pattern</i></font> can be used to encapsulate object construction. The goal of factories is create objects without exposing clients to the  implementations and initializations of those objects. In the <font  face="Verdana, Arial, Helvetica, sans-serif">SomeClass</font> example, the construction and initialization of <font  face="Verdana, Arial, Helvetica, sans-serif">SomeClass</font>, which implements the <font  face="Verdana, Arial, Helvetica, sans-serif">SomeInterface</font> abstract class, is contained within the <font  face="Verdana, Arial, Helvetica, sans-serif">New_SomeInterface</font> function, which follows the factory design pattern:</font>
</p>


<a name="998507"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">int New_SomeInterface(SomeInterface** ret) </font><a name="1001855"> </a>
<font face="Courier New">{</font><a name="1001856"> </a>
<font face="Courier New">  // create the object</font><a name="1001857"> </a>
<font face="Courier New">  SomeClass* out = new SomeClass();</font><a name="1001858"> </a>
<font face="Courier New">  if (!out) return -1;</font><a name="1001859"> </a>
<font face="Courier New">  </font><a name="1001860"> </a>
<font face="Courier New">  // init the object</font><a name="1001861"> </a>
<font face="Courier New">  if (out-&gt;Init() == FALSE)</font><a name="1001862"> </a>
<font face="Courier New">  {</font><a name="1001863"> </a>
<font face="Courier New">    delete out;</font><a name="1001864"> </a>
<font face="Courier New">    return -1;</font><a name="1001865"> </a>
<font face="Courier New">  }</font><a name="1001866"> </a>
<font face="Courier New"></font><a name="1001867"> </a>
<font face="Courier New">  // cast to the interface</font><a name="1001868"> </a>
<font face="Courier New">  *ret = static_cast&lt;SomeInterface*&gt;(out);</font><a name="1001869"> </a>
<font face="Courier New">  return 0;</font><a name="1001870"> </a>
<font face="Courier New">}</font><a name="1001871"> </a>
</pre>
</font></td>
  </tr>
</table>



<br></font>

<a name="998509"> </a><font face="Times New Roman">Figure 6.   Encapsulating the Constructor</font>
<p>
  <a name="1003577"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The factory is the class that actually manages the creation of separate instances of a component for use. In XPCOM, factories are implementations of the <font  face="Verdana, Arial, Helvetica, sans-serif">nsIFactory</font> interface, and they use a factory design pattern like the example above to abstract and encapsulate object construction and initialization.</font>
</p>


<p>
  <a name="1003578"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The example in <a href="quicktour2.html#998509"><font  face="Verdana, Arial, Helvetica, sans-serif"><i>Figure 6</i></font></a> above is a simple and stateless version of factories, but real world programming isn't usually so simple, and in general factories need to store state. At a minimum, the factory needs to preserve information about what objects it has created. When a factory manages instances of a class built in a dynamic shared library, for example, it needs to know when it can unload the library. When the factory preserves state, you can ask if there are outstanding references and find out if the factory created any objects.</font>
</p>


<p>
  <a name="1003579"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Another state that a factory can save is whether or not an object is a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>singleton</i></font>. For example, if a factory creates an object that is supposed to be a singleton, then subsequent calls to the factory for the object should return the same object. Though there are tools and better ways to handle singletons (which we'll discuss when we talk about the <font  face="Verdana, Arial, Helvetica, sans-serif">nsIServiceManager</font>), a developer may want to use this information to ensure that only one singleton object can exist despite what the callers do.</font>
</p>


<p>
  <a name="1003580"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The requirements of a factory class can be handled in a strictly functional way, with state being held by global variables, but there are benefits to using classes for factories. When you use a class to implement the functionality of a factory, for example, you derive from the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface, which allows you to manage the lifetime of the factory objects themselves. This is important when you want to group sets of factories together and determine if they can be unloaded. Another benefit of using the <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font> interface is that you can support other interfaces as they are introduced. As we'll show when we discuss <font  face="Verdana, Arial, Helvetica, sans-serif">nsIClassInfo</font>, some factories support querying information about the underlying implementation, such as what language the object is written in, interfaces that the object supports, etc. This kind of "future-proofing" is a key advantage that comes along with deriving from <font  face="Verdana, Arial, Helvetica, sans-serif">nsISupports</font>. </font>
</p>


<h3>
  <a name="998518"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">XPIDL and Type Libraries</font>
</h3>


<p>
  <a name="1003586"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">An easy and powerful way to define an interface-indeed, a requirement for defining interfaces in a cross-platform, language neutral development environment-is to use an <font  face="Verdana, Arial, Helvetica, sans-serif"><i>interface definition language</i></font> (IDL). XPCOM uses its own variant of the CORBA OMG Interface Definition Language (IDL) called XPIDL, which allows you to specify methods, attributes and constants of a given interface, and also to define interface inheritence.</font>
</p>


<p>
  <a name="1003587"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">There are some drawbacks to defining your interface using XPIDL. There is no support for multiple inheritence, for one thing. If you define a new interface, it cannot derive from more than one interface. Another limitation of interfaces in XPIDL is that method names must be unique. You can not have two methods with the same name that take different parameters, and the workaround-having multiple function names-isn't pretty:</font>
</p>

<pre>
<font face="Courier New">void FooWithInt(in int x);</font><a name="1003588"> </a>
<font face="Courier New">void FooWithString(in string x);</font><a name="1003589"> </a>
<font face="Courier New">void FooWithURI(in nsIURI x);</font><a name="1003590"> </a>
</pre>

<p>
  <a name="1003591"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">However, these shortcomings pale in comparison to the functionality gained by using XPIDL. XPIDL allows you to generate <font  face="Verdana, Arial, Helvetica, sans-serif"><i>type libraries</i></font>, or typelibs, which are files with the extension <font  face="Verdana, Arial, Helvetica, sans-serif"><i>.xpt</i></font>. The type library is a binary representation of an interface or interfaces. It provides programmatic control and access of the interface, which is crucial for interfaces used in the non C++ world. When components are accessed from other languages, as they can be in XPCOM, they use the binary type library to access the interface, learn what methods it supports, and call those methods. This aspect of XPCOM is called <font  face="Verdana, Arial, Helvetica, sans-serif"><i>XPConnect</i></font>. XPConnect is the layer of XPCOM that provides access to XPCOM components from languages such as JavaScript. See <a href="using_components.html#1007716">"Connecting to Components from the Interface" on page 30</a> for more information about XPConnect.</font>
</p>


<p>
  <a name="1003924"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When a component is accessible from a language other than C++, such as JavaScript, its interface is said to be "reflected" into that language. Every reflected interface must have a corresponding type library. Currently you can write components in C, C++, JavaScript, or Python, and there are efforts underway to build XPCOM bindings for Ruby and Perl as well.

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif">
<h4>
  <a name="1003951"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Writing Components in Other Languages</font>
</h4>

<a name="1003969"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Though you do not have access to some of the tools that XPCOM provides for C++ developers (such as macros, templates, smart pointers, and others) when you create components in other languages, you may be so comfortable with the language itself that you can eschew C++ altogether and build, for example, Python-based XPCOM components that can be used from JavaScript or vice versa. </font><a name="1004535"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">See the "References" section in Appendix C for more information about Python and other languages for which support has been added in XPCOM.</font></font></td>
  </tr>
</table>



</font>
</p>


<p>
  <a name="1003592"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">All of the public interfaces in XPCOM are defined using the XPIDL syntax. Type libraries and C++ header files are generated from these IDL files, and the tool that generates these files is called the <font  face="Verdana, Arial, Helvetica, sans-serif"><i>xpidl compiler</i></font>. The section <a href="weblock.html#999326">"Defining the Weblock Interface in XPIDL" on page 103</a> describes the XPIDL syntax in detail.</font>
</p>


<h2>
  <a name="1003594"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">XPCOM Services</font>
</h2>


<p>
  <a name="1003996"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">When clients use components, they typically <font  face="Verdana, Arial, Helvetica, sans-serif"><i>instantiate</i></font> a new object each time they need the functionality the component provides. This is the case when, for example, clients deal with files: each separate file is represented by a different object, and several file objects may be being used at any one time. </font>
</p>


<p>
  <a name="1004045"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">But there is also a kind of object known as a <font  face="Verdana, Arial, Helvetica, sans-serif"><i>service</i></font>, of which there is always only one copy (though there may be many services running at any one time). Each time a client wants to access the functionality provided by a service, they talk to the same instance of that service. When a user looks up a phone number in a company database, for example, probably that database is being represented by an "object" that is the same for all co-workers. If it weren't, the application would need to keep two copies of a large database in memory, for one thing, and there might also be inconsistencies between records as the copies diverged. </font>
</p>


<p>
  <a name="1004069"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Providing this single point of access to functionality is what the singleton design pattern is for, and what services do in an application (and in a development environment like XPCOM).</font>
</p>


<p>
  <a name="1004030"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">In XPCOM, in addition to the component support and management, there are a number of services that help the developer write cross platform components. These services include a cross platform file abstraction which provides uniform and powerful access to files, directory services which maintain the location of application- and system-specific locations, memory management to ensure everyone uses the same memory allocator, and an event notification system that allows passing of simple messages. The tutorial will show each of these component and services in use, and <font  face="Verdana, Arial, Helvetica, sans-serif"><i>Appendix B</i></font> has a complete interface listing of these areas.</font>
</p>


<h2>
  <a name="1004604"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">XPCOM Types</font>
</h2>


<p>
  <a name="1004612"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">There are many XPCOM declared types and simple macros that we will use in the following samples.  Most of these types are simple mappings.  The most common types are described in the following sections:</font>
</p>

<ul>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1004702"> </a><a href="quicktour2.html#1004674">"Method Types"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1004710"> </a><a href="quicktour2.html#1004762">"Reference Counting"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1004715"> </a><a href="quicktour2.html#1004688">"Status Codes"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1004720"> </a><a href="quicktour2.html#1004634">"Variable mappings"</a></font>
  <font  face="Verdana, Arial, Helvetica, sans-serif"><li ><a name="1004725"> </a><a href="quicktour2.html#1004640">"Common XPCOM Error Codes"</a></font>
</ul>

<h3>
  <a name="1004674"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Method Types</font>
</h3>


<p>
  <a name="1004755"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">The following are a set of types for ensuring correct calling convention and return time of XPCOM methods.</font>
</p>


<a name="1004932"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IMETHOD</font><a name="1004772"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004774"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Method declaration return type.  XPCOM method declarations should use this as their return type.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IMETHODIMP</font><a name="1004776"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004778"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Method Implementation return type.  XPCOM method implementations should use this as their return time.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IMETHODIMP_(type)</font><a name="1004780"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004782"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Special case implementation return type.  Some methods such as AddRef and Release do not return the default return type.  This exception is regrettable, but required for COM compliance.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IMPORT</font><a name="1004784"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004786"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Forced the method to be resolved internally by the shared library.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_EXPORT</font><a name="1004788"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004790"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Forces the method to be exported by the shared library.</font></font></td>
  </tr>
</table>



<br></font>


<h3>
  <a name="1004762"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Reference Counting</font>
</h3>


<p>
  <a name="1004763"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Set of macros for managing reference counting.</font>
</p>


<a name="1004928"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ADDREF</font><a name="1004797"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004799"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Calls AddRef on an nsISupports object</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IF_ADDREF</font><a name="1004801"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004803"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Same as above but checks for null before calling AddRef</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_RELEASE</font><a name="1004805"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004807"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Calls Release on an nsISupports object</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_IF_RELEASE</font><a name="1004809"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004811"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Same as above but check for null before calling Release</font></font></td>
  </tr>
</table>



<br></font>


<h3>
  <a name="1004688"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Status Codes</font>
</h3>


<p>
  <a name="1004687"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">These macros test status codes</font>
</p>


<a name="1004924"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_FAILED</font><a name="1004820"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004822"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Return true if the passed status code was a failure.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_SUCCEEDED</font><a name="1004824"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004826"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returns true is the passed status code was a success.</font></font></td>
  </tr>
</table>



<br></font>


<h3>
  <a name="1004634"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Variable mappings</font>
</h3>


<a name="1004889"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"> 

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">nsrefcnt</font><a name="1004835"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004837"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"><font  face="Verdana, Arial, Helvetica, sans-serif">Default reference count type. Maps to an 32 bit integer. </font> </font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">nsresult</font><a name="1004896"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004898"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Default error type.  Maps to a 32 bit integer. </font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">nsnull</font><a name="1004839"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004841"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Default null value.  </font></font></td>
  </tr>
</table>



<br></font>


<h3>
  <a name="1004640"> </a><font color="#003366"  face="Verdana, Arial, Helvetica, sans-serif">Common XPCOM Error Codes</font>
</h3>


<a name="1004917"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">

<table border="1" cellpadding="5" cellspacing="0">
  <caption><b><i><font face="Verdana, Arial, Helvetica, sans-serif"></font></i></b></caption>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_NOT_INITIALIZED</font><a name="1004852"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004854"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when an instance is not initialized.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_ALREADY_INITIALIZED</font><a name="1004856"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004858"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when an instance is already initialized</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_NOT_IMPLEMENTED</font><a name="1004860"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004862"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned by an unimplemented method</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_NO_INTERFACE   </font><a name="1004864"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004866"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when a given interface is not supported.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_NULL_POINTER   </font><a name="1004868"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004870"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when a valid pointer is found to be nsnull. </font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_FAILURE       </font><a name="1004872"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004874"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when a method fails.  Generic error case.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_UNEXPECTED     </font><a name="1004876"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004878"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when an unexpected error occurs.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_OUT_OF_MEMORY </font><a name="1004880"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004882"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when a memory allocation fails.</font></font></td>
  </tr>
  <tr>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><pre>
<font face="Courier New">NS_ERROR_FACTORY_NOT_REGISTERED </font><a name="1004884"> </a>
</pre>
</font></td>
    <td><font face="Verdana, Arial, Helvetica, sans-serif"><a name="1004886"> </a><font  face="Verdana, Arial, Helvetica, sans-serif">Returned when a requested class is not registered.</font></font></td>
  </tr>
</table>



<br></font>


<p>
  <a name="1004608"> </a><font  face="Verdana, Arial, Helvetica, sans-serif"></font>
</p>
</blockquote>

<hr>

<table border="0" cellspacing="0" cellpadding="0">
  <tr>
  <td><font size="1"><font face="courier"> Copyright (c)
  2003 by Doug Turner and Ian Oeschger. This material may be
  distributed only subject to the terms and conditions set forth in
  the <a href="http://www.opencontent.org/openpub/">Open Publication
  License</a>, v1.02 or later. Distribution of substantively modified
  versions of this document is prohibited without the explicit
  permission of the copyright holder. Distribution of the work or
  derivative of the work in any standard (paper) book form is
  prohibited unless prior permission is obtained from the copyright
  holder.</td>
  </tr>
</table>

<table width="331" border="0" cellpadding="0" cellspacing="0">
  <tr>
    <td><a href="newbookTOC.html"><img src="images/navtoc.gif" width="84" height="23" border="0"
    alt="TOC"> </a></td>
    <td><a href="preface.html"><img src="images/navprev.gif" width="81" height="23" border="0"
    alt="PREV"> </a></td>
    <td><a href="using_components.html"><img src="images/navnext.gif" width="81" height="23" border="0"
    alt="NEXT"> </a></td>
    <td><a href="newbookIX.html"><img src="images/navidx.gif" width="85" height="23" border="0"
    alt="INDEX"> </a></td>
  </tr>
</table>

</body>
</html>
